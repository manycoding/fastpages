{
  
    
        "post0": {
            "title": "Practical Deep Learning in Life - Plants",
            "content": "Why practical, again? . In the previous article I shared my approach to engagement with life. The title contains practical to emphasize my approach - it&#39;s fulfilling to learn or do something, solving a real problem rather than artificial. Imagine you want to start jogging - until you put your sneakers on and start moving you are not jogging. You can have goals, desires, expectations about jogging, you can learn theory behind it and watch videos but all of this is not the same as jogging. You could gain lots of knowledge but when you practice this knowledge is mostly your narrow representations. . That was a big lesson for me - to engage with the thing I want to do directly. I can give the same example about Deep Learning - I could go through all popular and interesting courses, solve all Kaggle&#39;s knowledge or kudos competitions, do homework. All of this doesn&#39;t really matter to me because real world - paid competitions and project - have real problems and constraints. They engage you and open for you what you really will be dealing with - creating awesome communications and relationships with clients, handling failures and mistakes, listening to feedback, making your shortcomings visible, marketing yourself. Many things you wouldn&#39;t know about. . My Ink . I am writing in a Jupyter notebook which I&#39;ll post through fastpages. I&#39;m adding these lines the latest and I give no excuse for inconsistencies. I want you to know that after wrapping the whole thing up I realized that I enjoy writing stories like the previous one more than explaining technical stuff. Partly because it&#39;s already explained by someone much better. Partly because I am not interested in this - I am interested in sharing my experience but THE CODE is mostly dry facts. . About the notebook itself, the whole time it feels like I&#39;m trying to fit something here which doesn&#39;t fit. Maybe I am not doing it in the right way. Maybe there&#39;s no right way. Also it requires some technical preparation, which creates contrast with using medium.com directly - a couple of paragraphs, a proofread and you&#39;re done. . The Competition . Let&#39;s jump in one of the most practical things for Deep Learning - paid Kaggle competitions. I&#39;ll share my solution to Plant Pathology 2020 - FGVC7 which put me in top 23%. . The goal is to build a model which predicts if tree leaves are healthy, have scab, rust or a combination. It made me wonder why so few classes - I&#39;m sure there are much more diseases than just 2. For a given photo like this we have to predict one label: rust . My Approach . I always like to start with something really simple, make it public and build up from it. So first I wrote this notebook which was the base. . I often check other works to see if there&#39;s something I don&#39;t know, especially the ones with fastai. If I use something in mine I tend to put the source url here on the top. It&#39;s my gratitude. Many people optimize for upvoting their work which seems about ego to me. I don&#39;t want to please their ego or mine, I want to be authentic and helpful. . Thanks this guy for metrics and k-folds. . https://www.kaggle.com/lextoumbourou/plant-pathology-2020-eda-training-fastai2 . Fastai2 docs . https://dev.fast.ai/ . #hide_output !pip install -q git+https://github.com/fastai/fastai2 !pip install -q git+https://github.com/fastai/fastcore !pip install -q iterative-stratification . I ran this notebook in Colab Pro because it took around 10 hours with 16GB GPU - the Kaggle competition run is limited to 6 hours. . I have a paid plan for Google Drive where I store the data - which actually allowed me to process 500GB and train the model for DeepFake challenge. The cons are that when the number of files gets bigger (350k) drive mounting stops to work. But here it was just 3642 images. . Colab Pro is cheap and easy-to-use. . from google.colab import drive drive.mount(&#39;/content/gdrive&#39;, force_remount=True) !mkdir /root/.kaggle . # imports and folders from fastai2.vision.all import * from iterstrat.ml_stratifiers import MultilabelStratifiedKFold root_dir = Path(&quot;/content/gdrive/My Drive/&quot;) path = root_dir/&quot;kaggle/Plants/&quot; path.mkdir(parents=True, exist_ok=True) . # downloading data from kaggle # !cp &quot;{root_dir}/kaggle/kaggle.json&quot; /root/.kaggle/kaggle.json # import kaggle . # !kaggle competitions download -c plant-pathology-2020-fgvc7 -p &quot;{path}/data&quot; -q . # !unzip -q &#39;{path}/plant-pathology-2020-fgvc7.zip&#39; -d &#39;{path}&#39; . len((path/&quot;images&quot;).ls()) . 3642 . The labels are stored in a CSV file and for some reason hot-encoded. Which misrepresents the problem. I think most people who read the description the first time thought it&#39;s a multi-label problem (where you need to predict multiple labels for a photo). . train_df = pd.read_csv(path/&quot;train.csv&quot;) train_df.head() . image_id healthy multiple_diseases rust scab . 0 Train_0 | 0 | 0 | 0 | 1 | . 1 Train_1 | 0 | 1 | 0 | 0 | . 2 Train_2 | 1 | 0 | 0 | 0 | . 3 Train_3 | 0 | 0 | 1 | 0 | . 4 Train_4 | 1 | 0 | 0 | 0 | . Preparation for k-folds ) . It&#39;s the first competition where I used cross-validation. It&#39;s important to make a right train, valid and test split. The model trains on data from the train split and it validates - calculates the loss and prints metrics - on the valid split. Metrics show us how good is the model. . But test split is something the model only makes predictions on. Kaggle competitions always have the test split prepared - but you don&#39;t see its labels, only a public score after submission and a private one after a challenge ends. In fact the private score is calculated on the test set you never see, the reason is to penalize overfitting. On real projects like Canadian housing price prediction I do the splits myself, and I have the labels. . Cross-validation, how I see it, is the idea of minimizing randomness from one split by makings n folds, each fold containing train and validation splits. You train the model on each fold, so you have n models. Then you take average predictions from all models, which supposedly give us more confidence in results. . In my opinion it&#39;s more important to make one right split, especially because CV takes n times more to train. But on Kaggle CV yields slightly better scores, thus the environment encourages people to use it. More info about splits and CV you can read in How (and why) to create a good validation set . strat_kfold = MultilabelStratifiedKFold(n_splits=5, random_state=42, shuffle=True) . train_df[&#39;fold&#39;] = -1 for i, (_, test_index) in enumerate(strat_kfold.split(train_df.image_id.values, train_df.iloc[:,1:].values)): train_df.iloc[test_index, -1] = i train_df.head() . image_id healthy multiple_diseases rust scab fold . 0 Train_0 | 0 | 0 | 0 | 1 | 3 | . 1 Train_1 | 0 | 1 | 0 | 0 | 0 | . 2 Train_2 | 1 | 0 | 0 | 0 | 0 | . 3 Train_3 | 0 | 0 | 1 | 0 | 3 | . 4 Train_4 | 1 | 0 | 0 | 0 | 2 | . 5 folds, 350 images per each. . train_df.fold.value_counts().plot.bar(); . train_df.query(&quot;image_id == &#39;Train_5&#39;&quot;) . image_id healthy multiple_diseases rust scab fold . 5 Train_5 | 1 | 0 | 0 | 0 | 1 | . get_image_files(path/&quot;images&quot;)[5] . Path(&#39;/content/gdrive/My Drive/kaggle/Plants/images/Test_64.jpg&#39;) . Because there&#39;s only one label per row, I transform the dataframe from one-hot to normal label name. . train_df.iloc[0, 1:][train_df.iloc[0, 1:] == 1].index[0] . &#39;scab&#39; . Datablock . # I keep the labels here because I can forget the order. Fuckin up the order fucks up your results. # LABEL_COLS = [&#39;healthy&#39;, &#39;multiple_diseases&#39;, &#39;rust&#39;, &#39;scab&#39;] . The batch size. The batch size affects GPU memory usage. The bigger it is - the faster training. I found the one which uses all the memory. . # BS = 100 BS = 8 . That&#39;s a fastai data block - the thing which helps to load, label, split and transform the data. It can be read as: . I want something for image categorization, . which I read from images folder using names in my dataframe, . label from the same dataframe, . split using the folds I defined earlier, . resize to the size I want, . and use transforms to help model generalize. . def get_data(fold=0, size=224): return DataBlock(blocks = (ImageBlock, CategoryBlock), get_x=ColReader(0, pref=path/&quot;images&quot;, suff=&quot;.jpg&quot;), get_y=lambda o:o.iloc[1:][o.iloc[1:] == 1].index[0], splitter=IndexSplitter(train_df[train_df.fold == fold].index), item_tfms=Resize(size), batch_tfms=aug_transforms(flip_vert=True), ).dataloaders(train_df, bs=BS) . dls = get_data() . A batch is a pack of data in GPU memory on which the computations are being done at once. As the size is 8, it means 8 photos are in memory at once. Here they are, with labels. The data is ready. . # dls = dblock.dataloaders(train_df, bs=BS) dls.show_batch() . Model . Each Kaggle challenge has it&#39;s own evaluation metric. Here it&#39;s ROC AUC which have a scary name - receiver operating characteristic curve. Making things simple is a virtue and a very rare trait in science generally and in AI in particular. . I have no idea why this metric. I won&#39;t explain what it means, I think this guy did a really good job. For me it looks like a metric to account for all these TP, FP, TN, FN predictions. I am not going to expain those either. . from sklearn.metrics import roc_auc_score def roc_auc(preds, targs, labels=range(4)): # One-hot encode targets targs = np.eye(4)[targs] return np.mean([roc_auc_score(targs[:,i], preds[:,i]) for i in labels]) def healthy_roc_auc(*args): return roc_auc(*args, labels=[0]) def multiple_diseases_roc_auc(*args): return roc_auc(*args, labels=[1]) def rust_roc_auc(*args): return roc_auc(*args, labels=[2]) def scab_roc_auc(*args): return roc_auc(*args, labels=[3]) . Commented code - my experiments. Fastai has lots of state-of-the-art pieces, I tried them one at a time on a smaller dataset and checked if it helped to train a better model. . CutMix is a technique to mix two photos - cut out a piece from one and put it on another. With this we create more combinations, i.e. create new data programmatically without actually taking photos. We make data plenty. . # from fastai2.callback.cutmix import CutMix . And here I tried a weighted loss - a loss that penalizes underrepresented class. Simply put, the number of labels is uneven - we have much fewer photos with multiple disease. When the model calculates loss it just takes the average loss, so we can have a situation where the performance is wonderful on all labels but terrible on multiple diseases. Something everybody wants to be aware of. With weighted loss we pretend this particular class is more important than others by multiplying its loss, so the model tries to optimize it more diligently. . The practice proved that creating multiple metrics and stopping training based on them works here better. . # loss = partial(CrossEntropyLossFlat, weights=tensor([1,1.5,1,1])) . That&#39;s all model code and you can compare it with pure Pytorch and TensorFlow2 implementations. Man, these people love to code. . But I simply get the data from a particular fold, create a model, add metrics. I believe resnet152 is the biggest resnet in pytorch. The larger the model - the larger is the capacity to learn differences we want. I also tried the biggest efficientnet just because I saw it somewhere but the best results I had with this . metric = partial(AccumMetric, flatten=False) def get_learner(fold, size=224): dls = get_data(fold, size) return cnn_learner(dls, resnet152, metrics=[ error_rate, metric(healthy_roc_auc), metric(multiple_diseases_roc_auc), metric(rust_roc_auc), metric(scab_roc_auc), metric(roc_auc)], # cbs=MixUp(0.5), # loss=LabelSmoothingCrossEntropy, ).to_fp16() . Many things are written about learning rate. The things which fastai takes care about, so I chose the default one which works in 95% of cases. . lr = 3e-3 . And that&#39;s the whole training process. I just trained 5 models on each fold and saved predictions for the test set. I also used big picture size - 450x800, which improved my results in comparison with 224x224. Unsurprisingly, larger images - more data to learn from. . The important thing is to find something to do meanwhile and not to fall a victim of checking constantly how it&#39;s going. . #hide_output test_df = pd.read_csv(path/&quot;test.csv&quot;) test_df.head() all_preds = [] for i in range(5): learn = get_learner(i, (450,800)) learn.fine_tune(30, lr, freeze_epochs=3) tst_dl = learn.dls.test_dl(test_df) preds, _ = learn.get_preds(dl=tst_dl) all_preds.append(preds) . Interpretation . Fastai has this helpful tool to check where the model made the most errors. Again, no surprises here - multiple diseases. I actually used it the first time, perhaps mostly for demonstration purposes. . interp = ClassificationInterpretation.from_learner(learn) . interp.plot_top_losses(9, figsize=(15, 10)) . Submission . Last but not least, we submit our predictions on the test dataset to Kaggle. We take the average from all 5 models. . subm = pd.read_csv(path/&quot;sample_submission.csv&quot;) . preds = np.mean(np.stack(all_preds), axis=0) . subm.iloc[:, 1:] = preds . subm.to_csv(&quot;submission.csv&quot;, index=False) . pd.read_csv(&quot;submission.csv&quot;) . image_id healthy multiple_diseases rust scab . 0 Test_0 | 0.006065 | 0.001795 | 0.991837 | 0.000302 | . 1 Test_1 | 0.001254 | 0.017110 | 0.981516 | 0.000121 | . 2 Test_2 | 0.001195 | 0.000296 | 0.000025 | 0.998483 | . 3 Test_3 | 0.999953 | 0.000004 | 0.000017 | 0.000026 | . 4 Test_4 | 0.000332 | 0.000758 | 0.998857 | 0.000053 | . ... ... | ... | ... | ... | ... | . 1816 Test_1816 | 0.000228 | 0.002940 | 0.996564 | 0.000268 | . 1817 Test_1817 | 0.012628 | 0.051876 | 0.000738 | 0.934758 | . 1818 Test_1818 | 0.001643 | 0.000960 | 0.997390 | 0.000008 | . 1819 Test_1819 | 0.999675 | 0.000057 | 0.000059 | 0.000209 | . 1820 Test_1820 | 0.000837 | 0.038257 | 0.000094 | 0.960812 | . 1821 rows × 5 columns . !kaggle competitions submit -c plant-pathology-2020-fgvc7 -f submission.csv -m &quot;450x800&quot; . . The practicality I like is that it didn&#39;t take me much time to get initial results and then I built from that. I also like that fastai took care about most things, which is clearly visible in comparison with other notebooks. . I think being in top 23% is a good result. There were 1317 participants in total, the first place has 0.98445 score. Good scores which are greater 0.9 start from 1000 place and mine is 295 with 0.96892. .",
            "url": "https://manycoding.github.io/fastpages/2020/05/29/Practical-Deep-Learning-in-Life-Plants.html",
            "relUrl": "/2020/05/29/Practical-Deep-Learning-in-Life-Plants.html",
            "date": " • May 29, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://manycoding.github.io/fastpages/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://manycoding.github.io/fastpages/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}